
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>All API &#8212; Normalisr  documentation</title>
    <link rel="stylesheet" href="static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script src="static/jquery.js"></script>
    <script src="static/underscore.js"></script>
    <script src="static/doctools.js"></script>
    <script src="static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="User API" href="user_api.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="all-api">
<h1>All API<a class="headerlink" href="#all-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-normalisr.association">
<span id="normalisr-association"></span><h2>normalisr.association<a class="headerlink" href="#module-normalisr.association" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.association.association_test_1">
<code class="sig-prename descclassname">normalisr.association.</code><code class="sig-name descname">association_test_1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vx</span></em>, <em class="sig-param"><span class="n">vy</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dy</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">dci</span></em>, <em class="sig-param"><span class="n">dcr</span></em>, <em class="sig-param"><span class="n">dimreduce</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">lowmem</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.association.association_test_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast linear association testing in single-cell non-cohort settings with covariates.</p>
<dl>
<dt>Single threaded version to allow for parallel computing wrapper. Mainly used for naive differential expression and co-expression. Computes exact P-value and effect size (gamma) with the model for linear association testing between each vector x and vector y:</dt><dd><p>y=gamma*x+alpha*C+epsilon,</p>
<p>epsilon~i.i.d. N(0,sigma**2).</p>
</dd>
</dl>
<p>Test statistic: conditional R**2 (or proportion of variance explained) between x and y.</p>
<p>Null hypothesis: gamma=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – Starting indices of dx. Only used for information passing.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – Starting indices of dy. Only used for information passing.</p></li>
<li><p><strong>dx</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Predictor matrix for a list of vector x to be tested, e.g. gene expression or grouping.</p></li>
<li><p><strong>dy</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_y</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Target matrix for a list of vector y to be tested, e.g. gene expression.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Covariate matrix as C.</p></li>
<li><p><strong>dci</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cov</em><em>)</em><em>)</em><em></em>) – Low-rank inverse matrix of dc*dc.T.</p></li>
<li><p><strong>dcr</strong> (<em>int</em>) – Rank of dci.</p></li>
<li><p><strong>dimreduce</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>ny</em><em>,</em><em>)</em><em>,</em><em>dtype='uint'</em><em>) or </em><em>int.</em>) – If each vector y doesn’t have full rank in the first place, this parameter is the loss of degree of freedom to allow for accurate P-value computation.</p></li>
<li><p><strong>lowmem</strong> (<em>bool</em>) – Whether to save memory by neither computing nor returning alpha.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – vx from input for information passing.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – vy from input for information passing.</p></li>
<li><p><strong>pv</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – P-values of association testing (gamma==0).</p></li>
<li><p><strong>gamma</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – Maximum likelihood estimator of gamma in model.</p></li>
<li><p><strong>alpha</strong> (<em>numpy.ndarray(shape=(n_x,n_y,n_cov)) or None</em>) – Maximum likelihood estimator of alpha in model if not lowmem else None.</p></li>
<li><p><strong>var_x</strong> (<em>numpy.ndarray(shape=(n_x,))</em>) – Variance of dx unexplained by covariates C.</p></li>
<li><p><strong>var_y</strong> (<em>numpy.ndarray(shape=(n_y,))</em>) – Variance of dy unexplained by covariates C.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.association.association_test_2">
<code class="sig-prename descclassname">normalisr.association.</code><code class="sig-name descname">association_test_2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vx</span></em>, <em class="sig-param"><span class="n">vy</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dy</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">sselectx</span></em>, <em class="sig-param"><span class="n">dimreduce</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">lowmem</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.association.association_test_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Like association_test_1, but takes a different subset of samples for each x.</p>
<p>See association_test_1 for additional details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – Starting indices of dx. Only used for information passing.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – Starting indices of dy. Only used for information passing.</p></li>
<li><p><strong>dx</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Predictor matrix for a list of vector x to be tested, e.g. gene expression or grouping.</p></li>
<li><p><strong>dy</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_y</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Target matrix for a list of vector y to be tested, e.g. gene expression.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Covariate matrix as C.</p></li>
<li><p><strong>sselectx</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype=bool</em><em>)</em>) – Subset of samples to use for each x.</p></li>
<li><p><strong>dimreduce</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>ny</em><em>,</em><em>)</em><em>,</em><em>dtype='uint'</em><em>) or </em><em>int.</em>) – If each vector y doesn’t have full rank in the first place, this parameter is the loss of degree of freedom to allow for accurate P-value computation.</p></li>
<li><p><strong>lowmem</strong> (<em>bool</em>) – Whether to save memory by neither computing nor returning alpha.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – vx from input for information passing.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – vy from input for information passing.</p></li>
<li><p><strong>pv</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – P-values of association testing (gamma==0).</p></li>
<li><p><strong>gamma</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – Maximum likelihood estimator of gamma in model.</p></li>
<li><p><strong>alpha</strong> (<em>numpy.ndarray(shape=(n_x,n_y,n_cov)) or None</em>) – Maximum likelihood estimator of alpha in model if not lowmem else None.</p></li>
<li><p><strong>var_x</strong> (<em>numpy.ndarray(shape=(n_x,))</em>) – Variance of dx unexplained by covariates C.</p></li>
<li><p><strong>var_y</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – Variance of dy unexplained by covariates C.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.association.association_test_4">
<code class="sig-prename descclassname">normalisr.association.</code><code class="sig-name descname">association_test_4</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vx</span></em>, <em class="sig-param"><span class="n">vy</span></em>, <em class="sig-param"><span class="n">prod</span></em>, <em class="sig-param"><span class="n">prody</span></em>, <em class="sig-param"><span class="n">prodyy</span></em>, <em class="sig-param"><span class="n">na</span></em>, <em class="sig-param"><span class="n">dimreduce</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">lowmem</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.association.association_test_4" title="Permalink to this definition">¶</a></dt>
<dd><p>Like association_test_1, but regards all other (untested) x’s as covariates when testing each x.
Also allows for dx==dy setting, where neither tested x or y is regarded as a covariate.</p>
<p>See association_test_1 for additional details. Other x’s are treated as covariates but their coefficients (alpha) would not be returned to reduce memory footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – Starting indices of dx.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – Starting indices of dy. Only used for information passing.</p></li>
<li><p><strong>prod</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x+n_cov</em><em>,</em><em>n_x+n_cov</em><em>)</em><em>)</em>) – A&#64;A.T, where A=numpy.block([dx,dc]).</p></li>
<li><p><strong>prody</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x+n_cov</em><em>,</em><em>n_y</em><em>)</em><em>) or </em><em>None</em>) – A&#64;dy.T, where A=numpy.block([dx,dc]). If None, indicating dx==dy and skipping tested y as a covariate.</p></li>
<li><p><strong>prodyy</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_y</em><em>,</em><em>)</em><em>) or </em><em>None</em>) – (dy**2).sum(axis=1). If None, indicating dx==dy and skipping tested y as a covariate.</p></li>
<li><p><strong>na</strong> (<em>tuple</em>) – (n_x,n_y,n_cov,n_cell,lenx). Numbers of (x’s, y’s, covariates, cells, x’s to compute association for)</p></li>
<li><p><strong>dimreduce</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>ny</em><em>,</em><em>)</em><em>,</em><em>dtype='uint'</em><em>) or </em><em>int.</em>) – If each vector y doesn’t have full rank in the first place, this parameter is the loss of degree of freedom to allow for accurate P-value computation.</p></li>
<li><p><strong>lowmem</strong> (<em>bool</em>) – Whether to save memory by neither computing nor returning alpha.</p></li>
<li><p><strong>ka</strong> (<em>dict</em>) – Keyword arguments passed to inv_rank.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – vx from input for information passing.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – vy from input for information passing.</p></li>
<li><p><strong>pv</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – P-values of association testing (gamma==0).</p></li>
<li><p><strong>gamma</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – Maximum likelihood estimator of gamma in model.</p></li>
<li><p><strong>alpha</strong> (<em>numpy.ndarray(shape=(n_x,n_y,n_cov)) or None</em>) – Maximum likelihood estimator of alpha in model if not lowmem else None.</p></li>
<li><p><strong>var_x</strong> (<em>numpy.ndarray(shape=(lenx,)) or None</em>) – Variance of dx unexplained by covariates C if prody is not None else None.</p></li>
<li><p><strong>var_y</strong> (<em>numpy.ndarray(shape=(lenx,n_y))</em>) – Variance of dy unexplained by covariates C or untested x.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.association.association_test_5">
<code class="sig-prename descclassname">normalisr.association.</code><code class="sig-name descname">association_test_5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vx</span></em>, <em class="sig-param"><span class="n">vy</span></em>, <em class="sig-param"><span class="n">prod</span></em>, <em class="sig-param"><span class="n">prody</span></em>, <em class="sig-param"><span class="n">prodyy</span></em>, <em class="sig-param"><span class="n">na</span></em>, <em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">dimreduce</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">lowmem</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.association.association_test_5" title="Permalink to this definition">¶</a></dt>
<dd><p>Like association_test_4, but uses mask to determine which X can affect which Y. Under development.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – Starting indices of dx.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – Starting indices of dy. Only used for information passing.</p></li>
<li><p><strong>prod</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x+n_cov</em><em>,</em><em>n_x+n_cov</em><em>)</em><em>)</em>) – A&#64;A.T, where A=numpy.block([dx,dc]).</p></li>
<li><p><strong>prody</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x+n_cov</em><em>,</em><em>n_y</em><em>)</em><em>) or </em><em>None</em>) – A&#64;dy.T, where A=numpy.block([dx,dc]). If None, indicating dx==dy and skipping tested y as a covariate.</p></li>
<li><p><strong>prodyy</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_y</em><em>,</em><em>)</em><em>) or </em><em>None</em>) – (dy**2).sum(axis=1). If None, indicating dx==dy and skipping tested y as a covariate.</p></li>
<li><p><strong>na</strong> (<em>tuple</em>) – (n_x,n_y,n_cov,n_cell,lenx). Numbers of (x’s, y’s, covariates, cells, x’s to compute association for)</p></li>
<li><p><strong>mask</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x</em><em>,</em><em>n_y</em><em>)</em><em>,</em><em>dtype=bool</em><em>)</em>) – Whether each X can affect each Y.</p></li>
<li><p><strong>dimreduce</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>ny</em><em>,</em><em>)</em><em>,</em><em>dtype='uint'</em><em>) or </em><em>int.</em>) – If each vector y doesn’t have full rank in the first place, this parameter is the loss of degree of freedom to allow for accurate P-value computation.</p></li>
<li><p><strong>lowmem</strong> (<em>bool</em>) – Whether to save memory by neither computing nor returning alpha.</p></li>
<li><p><strong>ka</strong> (<em>dict</em>) – Keyword arguments passed to inv_rank.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – vx from input for information passing.</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – vy from input for information passing.</p></li>
<li><p><strong>pv</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – P-values of association testing (gamma==0).</p></li>
<li><p><strong>gamma</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – Maximum likelihood estimator of gamma in model.</p></li>
<li><p><strong>alpha</strong> (<em>numpy.ndarray(shape=(n_x,n_y,n_cov)) or None</em>) – Maximum likelihood estimator of alpha in model if not lowmem else None.</p></li>
<li><p><strong>var_x</strong> (<em>numpy.ndarray(shape=(lenx,n_y))</em>) – Variance of dx unexplained by covariates C or untested x.</p></li>
<li><p><strong>var_y</strong> (<em>numpy.ndarray(shape=(lenx,n_y))</em>) – Variance of dy unexplained by covariates C or untested x.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.association.association_tests">
<code class="sig-prename descclassname">normalisr.association.</code><code class="sig-name descname">association_tests</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dy</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">bsx</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">bsy</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">nth</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">lowmem</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">return_dot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">single</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">bs4</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.association.association_tests" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs association tests between all pairs of two (or one) variables. Performs parallel computation with multiple processes on the same machine.</p>
<p>Allows multiple options to treat other/untested dx when testing on one (see parameter <em>single</em>).</p>
<p>Performs parallel computation with multiple processes on the same machine.</p>
<dl>
<dt>Model for differential expression between X and Y:</dt><dd><p>Y=gamma*X+alpha*C+epsilon,</p>
<p>epsilon~i.i.d. N(0,sigma**2).</p>
</dd>
</dl>
<p>Test statistic: conditional R**2 (or proportion of variance explained) between Y and X.</p>
<p>Null hypothesis: gamma=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dx</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Normalized matrix X.</p></li>
<li><p><strong>dy</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_y</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype=float</em><em>) or </em><em>None</em>) – Normalized matrix Y. If None, indicates dy=dx, i.e. self-association between pairs within X.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype=float</em><em>)</em>) – Normalized covariate matrix C.</p></li>
<li><p><strong>bsx</strong> (<em>int</em>) – Batch size, i.e. number of Xs in each computing batch. Defaults to 500.</p></li>
<li><p><strong>bsy</strong> (<em>int</em>) – Batch size, i.e. number of Xs in each computing batch. Defaults to 500. Ignored if dy is None.</p></li>
<li><p><strong>nth</strong> (<em>int</em>) – Number of parallel processes. Set to 0 for using automatically detected CPU counts.</p></li>
<li><p><strong>lowmem</strong> (<em>bool</em>) – Whether to replace alpha in return value with None to save memory</p></li>
<li><p><strong>return_dot</strong> (<em>bool</em>) – Whether to return dot product betwen dx and dy instead of coefficient gamma</p></li>
<li><p><strong>single</strong> (<em>int</em>) – <p>Type of association test to perform that determines which cells and covariates are used for
each association test between X and Y. Accepts the following values:</p>
<ul>
<li><p>0:    Simple pairwise association test between each X and Y across all cells.</p></li>
<li><p>1:    Association test for each X uses only cells that have all zeros in dx for all other Xs. A typical application is low-MOI CRISPR screen.</p></li>
<li><p>4:    Association test for each X uses all cells but regarding all other Xs as covariates that confound mean expression levels. This is suitable for high-MOI CRISPR screen.</p></li>
<li><p>5:    Similar with 4 but uses mask to determine which X can affect which Y. Under development.</p></li>
</ul>
</p></li>
<li><p><strong>bs4</strong> (<em>int</em>) – Batch size for matrix product when single=4. Defaults to 500.</p></li>
<li><p><strong>ka</strong> (<em>dict</em>) – Keyword arguments passed to normalisr.association.association_test_X. See below.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>P-values</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – Differential expression P-value matrix.</p></li>
<li><p><strong>dot/gamma</strong> (<em>numpy.ndarray(shape=(n_x,n_y))</em>) – If return_dot, inner product between X and Y pairs after removing covariates. Otherwise, matrix gamma.</p></li>
<li><p><strong>alpha</strong> (<em>numpy.ndarray(shape=(n_x,n_y,n_cov)) or None</em>) – Maximum likelihood estimators of alpha, separatly tested for each grouping if not lowmem else None.</p></li>
<li><p><strong>varx</strong> (<em>numpy.ndarray(shape=(n_x)) or numpy.ndarray(shape=(n_x,n_y)) or None</em>) – Variance of grouping after removing covariates if dy is not None and single!=5 else None</p></li>
<li><p><strong>vary</strong> (<em>numpy.ndarray(shape=(n_y)) if single==0 else numpy.ndarray(shape=(n_x,n_y))</em>) – Variance of gene expression after removing covariates.
Its shape depends on parameter single.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dimreduce</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_y</em><em>,</em><em>)</em><em>,</em><em>dtype=int</em><em>) or </em><em>int</em>) – If dy doesn’t have full rank, such as due to prior covariate removal (although the recommended method is to leave covariates in dc), this parameter allows to specify the loss of ranks/degrees of freedom to allow for accurate P-value computation. Default is 0, indicating no rank loss.</p></li>
<li><p><strong>mask</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_x</em><em>,</em><em>n_y</em><em>)</em><em>,</em><em>dtype=bool</em><em>)</em>) – Whether each X can affect each Y. Only active for single==5.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.association.inv_rank">
<code class="sig-prename descclassname">normalisr.association.</code><code class="sig-name descname">inv_rank</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">logger</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mpc</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">qr</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.association.inv_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes matrix (pseudo-)inverse and rank with SVD.</p>
<p>Eigenvalues smaller than tol*largest eigenvalue are set to 0. Rank of inverted matrix is also returned. Provides to limit the number of eigenvalues to speed up computation. Broadcasts to the last 2 dimensions of the matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>..</em><em>,</em><em>n</em><em>,</em><em>n</em><em>)</em><em>,</em><em>dtype=float</em><em>)</em>) – 2-D or higher matrix to be inverted</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – Eigenvalues &lt; tol*maximum eigenvalue are treated as zero.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <p>Method to compute eigenvalues:</p>
<ul>
<li><p>auto: Uses scipy for n&lt;mpc or mpc==0 and sklearn otherwise</p></li>
<li><p>scipy: Uses scipy.linalg.svd</p></li>
<li><p>scipys: NOT IMPLEMENTED. Uses scipy.sparse.linalg.svds</p></li>
<li><p>sklearn: Uses sklearn.decomposition.TruncatedSVD</p></li>
</ul>
</p></li>
<li><p><strong>logger</strong> (<em>object</em>) – Logger to output warning. Defaults (None) to logging module</p></li>
<li><p><strong>mpc</strong> (<em>int</em>) – Maximum rank or number of eigenvalues/eigenvectors to consider.
Defaults to 0 to disable limit.
For very large input matrix, use a small value (e.g. 500) to save time at the cost of accuracy.</p></li>
<li><p><strong>qr</strong> (<em>int</em>) – Whether to use QR decomposition for matrix inverse.
Only effective when method=sklearn, or =auto that defaults to sklearn.
* 0:    No
* 1:    Yes with default settings
* 2+:   Yes with n_iter=qr for sklearn.utils.extmath.randomized_svd</p></li>
<li><p><strong>ka</strong> (<em>Keyword args passed to method</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mi</strong> (<em>numpy.ndarray(shape=(…,n,n),dtype=float)</em>) – Pseudo-inverse matrices</p></li>
<li><p><strong>r</strong> (<em>numpy.ndarray(shape=(…),dtype=int) or int</em>) – Matrix ranks</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.association.prod1">
<code class="sig-prename descclassname">normalisr.association.</code><code class="sig-name descname">prod1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vx</span></em>, <em class="sig-param"><span class="n">vy</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.association.prod1" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickleable function for matrix product that keeps information</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – Information passed</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – Information passed</p></li>
<li><p><strong>dx</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>..</em><em>,</em><em>n</em><em>)</em><em>)</em>) – Matrix for multiplication</p></li>
<li><p><strong>dy</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>..</em><em>,</em><em>n</em><em>)</em><em>)</em>) – Matrix for multiplication</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vx</strong> (<em>any</em>) – vx</p></li>
<li><p><strong>vy</strong> (<em>any</em>) – vy</p></li>
<li><p><strong>product</strong> (<em>numpy.ndarray(shape=(…))</em>) – dx&#64;dy.T</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.binnet">
<span id="normalisr-binnet"></span><h2>normalisr.binnet<a class="headerlink" href="#module-normalisr.binnet" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.binnet.bh">
<code class="sig-prename descclassname">normalisr.binnet.</code><code class="sig-name descname">bh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pv</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.binnet.bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts P-values to Q-values using Benjamini–Hochberg procedure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pv</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n</em><em>,</em><em>)</em><em>)</em>) – P-values.</p></li>
<li><p><strong>weight</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n</em><em>,</em><em>)</em><em>) or </em><em>None</em>) – Weight of each P-value. Defaults (None) to equal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Q-values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n,))</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Controlling the false discovery rate: a practical and powerful approach to multiple testing, Benjamini and Hochberg. 1995</p>
</dd></dl>

<dl class="py function">
<dt id="normalisr.binnet.binnet">
<code class="sig-prename descclassname">normalisr.binnet.</code><code class="sig-name descname">binnet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="n">qcut</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.binnet.binnet" title="Permalink to this definition">¶</a></dt>
<dd><p>Binarizes P-value co-expresion network to thresholded Q-value network.</p>
<p>Q-values are computed separately per row to account for differences in the number of genes co-expressed, especially by master regulators, using Benjamini–Hochberg procedure. Co-expression Q-value matrix is thresholded for return.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_gene</em><em>)</em><em>,</em><em>dtype=float</em><em>)</em>) – Symmetric co-expression P-value matrix.</p></li>
<li><p><strong>qcut</strong> (<em>float</em>) – Cutoff for Q-value network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Binarized, assymmetric co-expression matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n_gene,n_gene),dtype=bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.binnet.nodiag">
<code class="sig-prename descclassname">normalisr.binnet.</code><code class="sig-name descname">nodiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">split</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.binnet.nodiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes diagonals from 2D matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>[</em><em>n1</em><em>,</em><em>n2</em><em>]</em><em>)</em>) – Input matrix</p></li>
<li><p><strong>split</strong> (<em>bool</em>) – Whether to output list of 1D arrays for each row instead of a single concatenated 1D array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>If split</strong> (<em>List of numpy.ndarray(shape=[n2 or n2-1]) for each row.</em>)</p></li>
<li><p><strong>Else</strong> (<em>numpy.ndarray(shape=(n1*n2-min(n1,n2),))</em>) – Reduced 1D array</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.binnet.rediag">
<code class="sig-prename descclassname">normalisr.binnet.</code><code class="sig-name descname">rediag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">fill</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.binnet.rediag" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a ‘nodiag’ed vector back to matrix of original shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n</em><em>,</em><em>)</em><em>)</em>) – Output array from nodiag(split=False)</p></li>
<li><p><strong>fill</strong> (<em>any</em>) – Values to fill in the diagonal entries</p></li>
<li><p><strong>shape</strong> (<em>tuple</em><em> or </em><em>None</em>) – Shape of original matrix. If omitted (None), assume original is a square matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Recovered original matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=shape)</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.coex">
<span id="normalisr-coex"></span><h2>normalisr.coex<a class="headerlink" href="#module-normalisr.coex" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.coex.coex">
<code class="sig-prename descclassname">normalisr.coex.</code><code class="sig-name descname">coex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.coex.coex" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs co-expression analyses for all gene pairs.</p>
<p>Performs parallel computation with multiple processes on the same machine.</p>
<dl>
<dt>Model for co-expression between genes i &amp; j:</dt><dd><p>X_i=gamma*X_j+alpha*C+epsilon,</p>
<p>epsilon~i.i.d. N(0,sigma**2).</p>
</dd>
</dl>
<p>Test statistic: conditional R**2 (or proportion of variance explained) between X_i and X_j.</p>
<p>Null hypothesis: gamma=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype=float</em><em>)</em>) – Normalized expression matrix X.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype=float</em><em>)</em>) – Normalized covariate matrix C.</p></li>
<li><p><strong>ka</strong> (<em>dict</em>) – Keyword arguments passed to normalisr.association.association_tests. See below.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>P-values</strong> (<em>numpy.ndarray(shape=(n_gene,n_gene))</em>) – Co-expression P-value matrix.</p></li>
<li><p><strong>dot</strong> (<em>numpy.ndarray(shape=(n_gene,n_gene))</em>) – Inner product of expression between gene pairs, after removing covariates.</p></li>
<li><p><strong>var</strong> (<em>numpy.ndarray(shape=(n_gene))</em>) – Variance of gene expression after removing covariates. Pearson R=(((dot/numpy.sqrt(var)).T)/numpy.sqrt(var)).T.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs</strong> (<em>int</em>) – Batch size, i.e. number of genes in each computing batch. Use 0 for default: Data transfer limited to 1GB, capped at bs=500.</p></li>
<li><p><strong>nth</strong> (<em>int</em>) – Number of parallel processes. Set to 0 for using automatically detected CPU counts.</p></li>
<li><p><strong>dimreduce</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>)</em><em>,</em><em>dtype=int</em><em>) or </em><em>int</em>) – If dt doesn’t have full rank, such as due to prior covariate removal (although the recommended method is to leave covariates in dc), this parameter allows to specify the loss of ranks/degrees of freedom to allow for accurate P-value computation. Default is 0, indicating no rank loss.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.de">
<span id="normalisr-de"></span><h2>normalisr.de<a class="headerlink" href="#module-normalisr.de" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.de.de">
<code class="sig-prename descclassname">normalisr.de.</code><code class="sig-name descname">de</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dg</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">bs</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.de.de" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs differential expression analyses for all genes against all groupings.</p>
<p>Allows multiple options to treat other groupings when testing on one grouping.</p>
<p>Performs parallel computation with multiple processes on the same machine.</p>
<dl>
<dt>Model for differential expression between gene Y and grouping X:</dt><dd><p>Y=gamma*X+alpha*C+epsilon,</p>
<p>epsilon~i.i.d. N(0,sigma**2).</p>
</dd>
</dl>
<p>Test statistic: conditional R**2 (or proportion of variance explained) between Y and X.</p>
<p>Null hypothesis: gamma=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dg</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_group</em><em>,</em><em>n_cell</em><em>)</em><em>)</em><em></em>) – Grouping matrix for a list of X to be tested, e.g. grouping by gene knock-out.</p></li>
<li><p><strong>dt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype=float</em><em>)</em>) – Normalized expression matrix Y.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype=float</em><em>)</em>) – Normalized covariate matrix C.</p></li>
<li><p><strong>bs</strong> (<em>int</em>) – Batch size, i.e. number of groupings and genes in each computing batch.
For single=0,1, splits groupings &amp; genes. Defaults to 500.
For single=4, defaults to splitting grouping by 10 and not on genes.</p></li>
<li><p><strong>ka</strong> (<em>dict</em>) – Keyword arguments passed to normalisr.association.association_test_*. See below.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>P-values</strong> (<em>numpy.ndarray(shape=(n_group,n_gene))</em>) – Differential expression P-value matrix.</p></li>
<li><p><strong>gamma</strong> (<em>numpy.ndarray(shape=(n_group,n_gene))</em>) – Differential expression log fold change matrix.</p></li>
<li><p><strong>alpha</strong> (<em>numpy.ndarray(shape=(n_group,n_gene,n_cov)) or None</em>) – Maximum likelihood estimators of alpha, separatly tested for each grouping if not lowmem else None.</p></li>
<li><p><strong>varg</strong> (<em>numpy.ndarray(shape=(n_group))</em>) – Variance of grouping after removing covariates.</p></li>
<li><p><strong>vart</strong> (<em>numpy.ndarray(shape=(n_group,n_gene))</em>) – Variance of gene expression after removing covariates.
It can depend on the grouping being tested depending on parameter single.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single</strong> (<em>int</em>) – <p>Option to deal with other groupings when testing one groupings v.s. gene expression.</p>
<ul>
<li><p>0:    Ignores other groupings (default).</p></li>
<li><dl class="simple">
<dt>1:    Excludes all cells belonging to any other grouping (value==1), assuming dg=0,1 only.</dt><dd><p>This is suitable for low-MOI CRISPR screens.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>4:    Treats other groupings as covariates for mean expression.</dt><dd><p>This is suitable for high-MOI CRISPR screens.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
<li><p><strong>lowmem</strong> (<em>bool</em>) – Whether to replace alpha in return value with None to save memory.</p></li>
<li><p><strong>nth</strong> (<em>int</em>) – Number of parallel processes. Set to 0 for using automatically detected CPU counts.</p></li>
<li><p><strong>dimreduce</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>)</em><em>,</em><em>dtype=int</em><em>) or </em><em>int</em>) – If dt doesn’t have full rank, such as due to prior covariate removal (although the recommended method is to leave covariates in dc), this parameter allows to specify the loss of ranks/degrees of freedom to allow for accurate P-value computation. Default is 0, indicating no rank loss.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>only for single=4</em>) – <p>Method to compute eigenvalues in SVD-based matrix inverse (for removal of covariates):</p>
<ul>
<li><p>auto: Uses scipy for n_matrix&lt;mpc or mpc==0 and sklearn otherwise. Default.</p></li>
<li><p>scipy: Uses scipy.linalg.svd.</p></li>
<li><p>scipys: NOT IMPLEMENTED. Uses scipy.sparse.linalg.svds.</p></li>
<li><p>sklearn: Uses sklearn.decomposition.TruncatedSVD.</p></li>
</ul>
</p></li>
<li><p><strong>mpc</strong> (<em>int</em><em>, </em><em>only for single=4</em>) – Uses only the top mpc singular values as non-zero in SVD-based matrix inverse. Here effectively reduces covariates to their top principal components. This reduction is performed after including other groupings as additional covariates. Defaults to 0 to disable dimension reduction. For very large grouping matrix, use a small value (e.g. 100) to save time at the cost of accuracy.</p></li>
<li><p><strong>qr</strong> (<em>int</em><em>, </em><em>only for single=4</em>) – <p>Whether to use QR decomposition method for SVD in matrix inverse. Only effective when method=sklearn, or =auto and defaults to sklearn. Takes the following values:</p>
<ul>
<li><p>0:    No (default).</p></li>
<li><p>1:    Yes with default settings.</p></li>
<li><p>2+:   Yes with n_iter=qr for sklearn.utils.extmath.randomized_svd.</p></li>
</ul>
</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>only for single=4</em>) – Eigenvalues &lt; tol*(maximum eigenvalue) are treated as zero in SVD-based matrix inverse. Default is 1E-8.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.gocovt">
<span id="normalisr-gocovt"></span><h2>normalisr.gocovt<a class="headerlink" href="#module-normalisr.gocovt" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.gocovt.goe">
<code class="sig-prename descclassname">normalisr.gocovt.</code><code class="sig-name descname">goe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">genelist</span></em>, <em class="sig-param"><span class="n">go_file</span></em>, <em class="sig-param"><span class="n">goa_file</span></em>, <em class="sig-param"><span class="n">bg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nmin</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">conversion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">evidence_set</span><span class="o">=</span><span class="default_value">{'EXP', 'HDA', 'HGI', 'HMP', 'HTP', 'IBA', 'IBD', 'IDA', 'IGI', 'IKR', 'IMP', 'IPI', 'IRD', 'ISA', 'ISM', 'ISO', 'ISS'}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.gocovt.goe" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds GO enrichment with goatools (0.7.11 tested).</p>
<p><strong>WARNING</strong>: This method is inexact for multi-maps in gene name conversion. However, it has a negligible effect in top GO component removal in single-cell co-expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>genelist</strong> (<em>list of str</em>) – Genes to search for enrichment.</p></li>
<li><p><strong>go_file</strong> (<em>str</em>) – File path for GO DAG (downloadable at <a class="reference external" href="http://geneontology.org/docs/download-ontology/">http://geneontology.org/docs/download-ontology/</a>)).</p></li>
<li><p><strong>goa_file</strong> (<em>str</em>) – File path for GO associations. See parameter <strong>conversion</strong>.</p></li>
<li><p><strong>bg</strong> (<em>list of str</em>) – Background genes.</p></li>
<li><p><strong>nmin</strong> (<em>int</em>) – Minimum number of principal genes required in GO.</p></li>
<li><p><strong>conversion</strong> (<em>tuple</em>) – <p>Conversion of <a class="reference external" href="https://docs.mygene.info/en/latest/doc/data.html">gene ID system</a> from gene list to the GO annotation.</p>
<ul>
<li><p>name_from:    Gene naming system of genelist. For gene names, use ‘symbol,alias’.</p></li>
<li><p>name_to:              Gene naming system of goa_file. Examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>Human: use ‘uniprot.Swiss-Prot’ (for GO annotations downloded from <a class="reference external" href="http://geneontology.org/gene-associations/goa_human.gaf.gz">http://geneontology.org/gene-associations/goa_human.gaf.gz</a>).</p></li>
<li><p>Mouse: use ‘MGI’ (for GO annotations downloded from <a class="reference external" href="http://current.geneontology.org/annotations/mgi.gaf.gz">http://current.geneontology.org/annotations/mgi.gaf.gz</a>).</p></li>
</ul>
</div></blockquote>
</li>
<li><p>species:              Species for gene name conversion. Examples: ‘human’, ‘mouse’.</p></li>
</ul>
</p></li>
<li><p><strong>evidence_set</strong> (<em>set of str</em>) – <a class="reference external" href="http://geneontology.org/docs/guide-go-evidence-codes/">GO evidences</a> to include. Defaults to non-expression based results to avoid circular reasoning bias.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>goe</strong> (<em>pandas.DataFrame</em>) – GO enrichment.</p></li>
<li><p><strong>gotop</strong> (<em>str</em>) – Top enriched GO ID</p></li>
<li><p><strong>genes</strong> (<em>list of str or None</em>) – Intersection list of genes in gotop and also bg. None if bg is None.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.gocovt.gotop">
<code class="sig-prename descclassname">normalisr.gocovt.</code><code class="sig-name descname">gotop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="n">namet</span></em>, <em class="sig-param"><span class="n">go_file</span></em>, <em class="sig-param"><span class="n">goa_file</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.gocovt.gotop" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the top variable GO enrichment of top principal genes in the binary co-expression network.</p>
<p>Principal genes are those with most co-expressed genes. They reflect the most variable pathways in the dataset. When the variable pathways are housekeeping related, they may conceal cell-type-specific co-expression patterns from being observed and understood. This function identifies the most variable pathway with gene ontology enrichment study of the top principal genes. Background genes are all genes provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_gene</em><em>)</em><em>,</em><em>dtype=bool</em><em>)</em>) – Binary co-expression network matrix.</p></li>
<li><p><strong>namet</strong> (<em>list of str</em>) – Gene names matching the rows and columns of net.</p></li>
<li><p><strong>go_file</strong> (<em>str</em>) – File path for GO DAG (downloadable at <a class="reference external" href="http://geneontology.org/docs/download-ontology/">http://geneontology.org/docs/download-ontology/</a>)).</p></li>
<li><p><strong>goa_file</strong> (<em>str</em>) – File path of GO annotation. See parameter <strong>conversion</strong> in normalisr.gocovt.goe.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Number of top principal genes to include for GO enrichment. Default is 100, giving good performance in general.</p></li>
<li><p><strong>ka</strong> (<em>dict</em>) – <strong>IMPORTANT</strong>: Keyword arguments passed to normalisr.gocovt.goe to determine how to perform GO enrichment study. If you see no gene mapped, check your gene name conversion rule in <strong>conversion</strong> parameter of normalisr.gocovt.goe. GO annotation have a specific gene ID system.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>principals</strong> (<em>list of str</em>) – List of principal genes.</p></li>
<li><p><strong>goe</strong> (<em>pandas.DataFrame</em>) – GO enrichment results.</p></li>
<li><p><strong>gotop</strong> (<em>str</em>) – Top enriched GO ID.</p></li>
<li><p><strong>genes</strong> (<em>list of str</em>) – List of genes in the gotop GO ID.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.gocovt.pc1">
<code class="sig-prename descclassname">normalisr.gocovt.</code><code class="sig-name descname">pc1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.gocovt.pc1" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes top principal component.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n1</em><em>,</em><em>n2</em><em>)</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n2,))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.gocovt.pccovt">
<code class="sig-prename descclassname">normalisr.gocovt.</code><code class="sig-name descname">pccovt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">namet</span></em>, <em class="sig-param"><span class="n">genes</span></em>, <em class="sig-param"><span class="n">condcov</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.gocovt.pccovt" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduces an extra covariate from the top principal component of given genes.</p>
<p>The extra covariate is the top principal component of normalized expressions of the selected genes. Adding a covariate from housekeeping pathway can reveal cell-type-specific activities in co-expression networks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Normalized expression matrix.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Existing normalized covariate matrix.</p></li>
<li><p><strong>namet</strong> (<em>list of str</em>) – List of gene names for rows in dt.</p></li>
<li><p><strong>genes</strong> (<em>list of str</em>) – List of gene names to include in finding top PC of their expression as an extra covariate.</p></li>
<li><p><strong>condcov</strong> (<em>bool</em>) – Whether to condition on existing covariates before computing top PC. Default: True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>New normalized covariate matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n_cov+1,n_cell))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.gocovt.toratio">
<code class="sig-prename descclassname">normalisr.gocovt.</code><code class="sig-name descname">toratio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.gocovt.toratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a pandas series of string to numeric ratios.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>s</strong> (<em>pandas.Series of string</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>panda.Series of float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.lcpm">
<span id="normalisr-lcpm"></span><h2>normalisr.lcpm<a class="headerlink" href="#module-normalisr.lcpm" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.lcpm.lcpm">
<code class="sig-prename descclassname">normalisr.lcpm.</code><code class="sig-name descname">lcpm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reads</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">nth</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ntot</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">varscale</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lowmem</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">nocov</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.lcpm.lcpm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Bayesian log CPM from raw read counts.</p>
<p>The technical sampling process is modelled as a Binomial distribution. The logCPM given read counts is a Bayesian inference problem and follows (shifted) Beta distribution. We use the expectation of posterior logCPM as the estimated expression levels. Resampling function is also provided to account for variances in the posterior distribution.</p>
<p><strong>Warning</strong>: Modifying keyword arguments other than nth or seed is neither recommended nor supported for function ‘lcpm’. Do so at your own risk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reads</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype='uint'</em><em>)</em>) – Read count matrix.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – Whether to normalize output to logCPM per cell. Default: True.</p></li>
<li><p><strong>nth</strong> (<em>int</em>) – Number of threads to use. Defaults to 0 to use all cores automatically detected.</p></li>
<li><p><strong>ntot</strong> (<em>int</em>) – Manually sets value of total number of reads in binomial distribution. Since the posterior distribution stablizes quickly as ntot increases, a large number, e.g. 1E9 is good for general use. Defaults to None to disable manual value.</p></li>
<li><p><strong>varscale</strong> (<em>float</em>) – Resamples estimated expression using the posterior Beta distribution. varscale sets the scale of variance than its actual value from the posterior distribution. Defaults to 0, to compute expectation with no variance.</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – Initial random seed if set.</p></li>
<li><p><strong>lowmem</strong> (<em>bool</em>) – Low memory mode disable mean and var in Returns and therefore saves memory.</p></li>
<li><p><strong>nocov</strong> (<em>bool</em>) – Whether to skip producing covariate variables. If True, output cov=None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>lcpm</strong> (<em>numpy.ndarray(shape=(n_gene,n_cell))</em>) – Estimated expression as logCPM from read counts.</p></li>
<li><p><strong>mean</strong> (<em>numpy.ndarray(shape=(n_gene,n_cell)) or None</em>) – Mean/Expectation of lcpm’s every entry’s posterior distribution. None if lowmem=True.</p></li>
<li><p><strong>var</strong> (<em>numpy.ndarray(shape=(n_gene,n_cell)) or None</em>) – Variance of lcpm’s every entry’s posterior distribution. None if lowmem=True.</p></li>
<li><p><strong>cov</strong> (<em>numpy.ndarray(shape=(3,n_cell))</em>) – Cellular summary covariates computed from read count matrix that may confound lcpm. Contains:</p>
<ul>
<li><p>cov[0]:       Log total read count per cell</p></li>
<li><p>cov[1]:       Number of 0-read genes per cell</p></li>
<li><p>cov[2]:       cov[0]**2</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.lcpm.scaling_factor">
<code class="sig-prename descclassname">normalisr.lcpm.</code><code class="sig-name descname">scaling_factor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">varname</span><span class="o">=</span><span class="default_value">'nt0mean'</span></em>, <em class="sig-param"><span class="n">v0</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">v1</span><span class="o">=</span><span class="default_value">'max'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.lcpm.scaling_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes scaling factor of variance normalization for every gene.</p>
<p>Lowly expressed genes need full variance normalization because of technical confounding from sequencing depth. Highly expressed genes do not need variance normalization because they are already accurately measured. The scaling factor operates as a exponential factor on the variance normalization scale for each gene. It should be maximum/minimum for genes with lowest/highest expression.</p>
<p><strong>Warning</strong>: Modifying keyword arguments is neither recommended nor supported for function ‘scaling_factor’. Do so at your own risk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype='uint'</em><em>)</em>) – Read count matrix.</p></li>
<li><p><strong>varname</strong> (<em>str</em>) – <p>Variable used to compute scaling factor for each gene. Can be:</p>
<ul>
<li><p>logtpropmean: log(dt.mean(axis=1)/dt.mean(axis=1).sum())</p></li>
<li><p>logtmeanprop: log((dt/dt.sum(axis=0)).mean(axis=1))</p></li>
<li><p>nt0mean:              (dt==0).mean(axis=1)</p></li>
<li><p>lognt0mean:   log((dt==0).mean(axis=1))</p></li>
<li><p>log1-nt0mean: log(1-(dt==0).mean(axis=1))</p></li>
</ul>
<p>Defaults to nt0mean.</p>
</p></li>
<li><p><strong>v0</strong> (<em>float</em>) – <p>Variable values to set scaling factor to 0 (for v0) and 1 (for v1). Linear assignment is applied for values inbetween. Can be:</p>
<ul>
<li><p>max:                  max</p></li>
<li><p>min:                  min</p></li>
<li><p>any float:    that float</p></li>
</ul>
</p></li>
<li><p><strong>v1</strong> (<em>float</em>) – <p>Variable values to set scaling factor to 0 (for v0) and 1 (for v1). Linear assignment is applied for values inbetween. Can be:</p>
<ul>
<li><p>max:                  max</p></li>
<li><p>min:                  min</p></li>
<li><p>any float:    that float</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Scaling factor of variance normalization for each gene</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n_gene,))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.lcpm.trigamma">
<code class="sig-prename descclassname">normalisr.lcpm.</code><code class="sig-name descname">trigamma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.lcpm.trigamma" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Trigamma_function">Tri-gamma function</a> .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>float</em><em> or </em><em>numpy.ndarray</em>) – Input value(s)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.norm">
<span id="normalisr-norm"></span><h2>normalisr.norm<a class="headerlink" href="#module-normalisr.norm" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.norm.compute_var">
<code class="sig-prename descclassname">normalisr.norm.</code><code class="sig-name descname">compute_var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">stepmax</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.norm.compute_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes variance normalization scale for each cell.</p>
<p>Performs a log-linear fit of the variance of each cell with covariates. Optionally use Expectation-Maximization(EM)-like method to iteratively fit mean and variance. For EM-like method, early-stopping is suggested because of overfitting issues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Bayesian LogCPM expression level matrix.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Covariate matrix.</p></li>
<li><p><strong>stepmax</strong> (<em>int</em>) – Maximum number of EM-like iterations of mean and variance normalization. Stop of iteration is also possible when relative accuracy target is reached. Defaults to 1, indicating no iterative normalization.</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – Relative accuracy target for early stopping. Constrains the maximum relative difference of fitted variance across cells compared to the last step. Defaults to 1E-6.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Inverse sqrt of fitted variance for each cell, i.e. the multiplier for variance normalization. For iterative normalization, the optimal step will be returned, defined as having the minimal max relative change across cells.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n_cell,))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.norm.normcov">
<code class="sig-prename descclassname">normalisr.norm.</code><code class="sig-name descname">normcov</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">c</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.norm.normcov" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes each continuous covariate to 0 mean and unit variance.</p>
<p>Optionally introduces constant 1 covariate as intercept. Categorical covariates should be in binary/one-hot form, and will be left unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Current covariate matrix. Use empty matrix with n_cov=0 if no covariate.</p></li>
<li><p><strong>c</strong> (<em>bool</em>) – Whether to introduce a constant 1 covariate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Processed covariate matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n_cov+1 if c else n_cov,n_cell))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.norm.normvar">
<code class="sig-prename descclassname">normalisr.norm.</code><code class="sig-name descname">normvar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">w</span></em>, <em class="sig-param"><span class="n">wt</span></em>, <em class="sig-param"><span class="n">dextra</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cat</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nth</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">bs</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">keepvar</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">normmean</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.norm.normvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs mean and variance normalizations.</p>
<p>Expression levels are normalized at mean and then at variance levels. Effectively each gene x is multiplied by w**wt[x] before removing covariates as dc*(w**wt[x]). Continuous covariates are normalized at variance levels. Effectively covariates are transformed to dc*w. Therefore, variance normalization for expression are scaled differently for each gene.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Bayesian logCPM matrix.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Covariate matrix.</p></li>
<li><p><strong>w</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cell</em><em>,</em><em>)</em><em>)</em>) – Computed variance normalization multiplier.</p></li>
<li><p><strong>wt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>)</em><em>)</em>) – Computed scaling factor for each gene.</p></li>
<li><p><strong>dextra</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_extra</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Extra data matrix also to be normalized like continuous covariates.</p></li>
<li><p><strong>cat</strong> (<em>int</em>) – <p>Whether to normalize categorical/binary covariates (those with only 0 or 1s). Defaults to 1.</p>
<ul>
<li><p>0:    No</p></li>
<li><p>1:    No except constant-1 covariate (intercept)</p></li>
<li><p>2:    Yes</p></li>
</ul>
</p></li>
<li><p><strong>nth</strong> (<em>int</em>) – Number of parallel threads.</p></li>
<li><p><strong>bs</strong> (<em>int</em>) – Batch size for each job.</p></li>
<li><p><strong>keepvar</strong> (<em>bool</em>) – Whether to maintain the variance of each gene invariant in mean normalization step. If so, expression variances are scaled back to original after mean normalization and before variance normalization. This function only affects overall variance level and its downstreams (e.g. differential expression log fold change). This function would not affect P-value computation. Default: True.</p></li>
<li><p><strong>normmean</strong> (<em>bool</em>) – Whether to remove covariates from expression at mean level. This is accounted for in hypothesis testing with linear models so this option makes no difference here. However, this can be helpful for other purposes of analyses.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>(dtn,dcn) or (dtn,dcn,dextran) if dextra is not None</em></p></li>
<li><p><strong>dtn</strong> (<em>numpy.ndarray(shape=(n_gene,n_cell))</em>) – Normalized gene expression matrix.</p></li>
<li><p><strong>dcn</strong> (<em>numpy.ndarray(shape=(n_cov,n_cell))</em>) – Normalized covariate matrix.</p></li>
<li><p><strong>dextran</strong> (<em>numpy.ndarray(shape=(n_extra,n_cell))</em>) – Normalized extra data matrix.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.norm.normvar1">
<code class="sig-prename descclassname">normalisr.norm.</code><code class="sig-name descname">normvar1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">w2</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.norm.normvar1" title="Permalink to this definition">¶</a></dt>
<dd><p>A single-threaded function to normalize a subset of transcriptome.</p>
<p>Should not be invoked directly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Bayesian logCPM matrix subset.</p></li>
<li><p><strong>dc</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cov</em><em>,</em><em>n_cell</em><em>)</em><em>)</em>) – Covariate matrix.</p></li>
<li><p><strong>w2</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_gene</em><em>,</em><em>)</em><em>)</em>) – Intemediate weight computed in normvar for subset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Normalized gene expression matrix subset.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n_gene,n_cell))</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.parallel">
<span id="normalisr-parallel"></span><h2>normalisr.parallel<a class="headerlink" href="#module-normalisr.parallel" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.parallel.autopooler">
<code class="sig-prename descclassname">normalisr.parallel.</code><code class="sig-name descname">autopooler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">it</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">a</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">dummy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_iter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">unordered</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">ka</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.parallel.autopooler" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses multiprocessing.Pool or multiprocessing.dummy.Pool to run iterator in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Number of parallel processes. Set to 0 to use auto detected CPU count.</p></li>
<li><p><strong>it</strong> (<em>iterator of</em><em> (</em><em>function</em><em>,</em><em>tuple</em><em>,</em><em>dict</em><em>)</em>) – Each iteration computes <strong>function</strong>(*<strong>tuple</strong>,**<strong>dict</strong>). <strong>function</strong> must be picklable, i.e. a base level function in a module or file.</p></li>
<li><p><strong>a</strong> (<em>tuple</em>) – Arguments passed to Pool.</p></li>
<li><p><strong>chunksize</strong> (<em>int</em>) – Number of iterations passed to each process each time.</p></li>
<li><p><strong>dummy</strong> (<em>bool</em>) – Whether to use multiprocessing.dummy instead</p></li>
<li><p><strong>return_iter</strong> (<em>bool</em>) – Not Implemented. Whether to return iterator of results instead. If not, return list of results.</p></li>
<li><p><strong>unordered</strong> (<em>bool</em>) – Whether the order of output matters.</p></li>
<li><p><strong>ka</strong> (<em>dict</em>) – Keyword arguments passed to Pool</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Results returned by function(*tuple,**dict), in same order of the iterator if not unordered.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list (or iterator if return_iter) of any</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-normalisr.qc">
<span id="normalisr-qc"></span><h2>normalisr.qc<a class="headerlink" href="#module-normalisr.qc" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="normalisr.qc.qc_outlier">
<code class="sig-prename descclassname">normalisr.qc.</code><code class="sig-name descname">qc_outlier</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dw</span></em>, <em class="sig-param"><span class="n">pcut</span><span class="o">=</span><span class="default_value">1e-10</span></em>, <em class="sig-param"><span class="n">outrate</span><span class="o">=</span><span class="default_value">0.02</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.qc.qc_outlier" title="Permalink to this definition">¶</a></dt>
<dd><p>Quality control by removing cell outliers by variance.</p>
<p>Fit normal distribution on the inverse sqrt variance to detect outliers. This is performed by iterative estimation of normal distribution with non-outliers and then determination of outliers with the normal distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dw</strong> (<em>numpy.ndarray</em><em>(</em><em>shape=</em><em>(</em><em>n_cell</em><em>,</em><em>)</em><em>)</em>) – Fitted inverse sqrt cell variance.</p></li>
<li><p><strong>pcut</strong> (<em>float</em>) – Bonferroni P-value cutoff for asserting outliers in a normal distribution of fitted cell variance. Default: 1E-10.</p></li>
<li><p><strong>outrate</strong> (<em>float</em>) – Upper bound of proportion of outliers on either side of variance distribution. Used for initial outlier assignment and final validity check. Default: 0.02.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether each cell passed QC</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray(shape=(n_cell,),dtype=bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="normalisr.qc.qc_reads">
<code class="sig-prename descclassname">normalisr.qc.</code><code class="sig-name descname">qc_reads</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reads</span></em>, <em class="sig-param"><span class="n">n_gene</span></em>, <em class="sig-param"><span class="n">nc_gene</span></em>, <em class="sig-param"><span class="n">ncp_gene</span></em>, <em class="sig-param"><span class="n">n_cell</span></em>, <em class="sig-param"><span class="n">nt_cell</span></em>, <em class="sig-param"><span class="n">ntp_cell</span></em><span class="sig-paren">)</span><a class="headerlink" href="#normalisr.qc.qc_reads" title="Permalink to this definition">¶</a></dt>
<dd><p>Quality control by bounding read counts.</p>
<p>Quality control is perform separately on genes based on their cell statisics and on cells based on their gene statistics, iteratively until dataset remains unchanged. A gene or cell is removed if any of the QC criteria is violated at any time in the iteration. All QC parameters can be set to 0 to disable QC filtering for that criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reads</strong> (<em>numpy.ndarray</em><em>(</em><em>(</em><em>n_gene</em><em>,</em><em>n_cell</em><em>)</em><em>,</em><em>dtype='uint'</em><em>)</em>) – Read count matrix.</p></li>
<li><p><strong>n_gene</strong> (<em>int</em>) – Lower bound on total read counts for gene QC.</p></li>
<li><p><strong>nc_gene</strong> (<em>int</em>) – Lower bound on number of expressed cells for gene QC.</p></li>
<li><p><strong>ncp_gene</strong> (<em>float</em>) – Lower bound on proportion of expressed cells for gene QC.</p></li>
<li><p><strong>n_cell</strong> (<em>int</em>) – Lower bound on total read counts for cell QC.</p></li>
<li><p><strong>nt_cell</strong> (<em>int</em>) – Lower bound on number of expressed genes for cell QC.</p></li>
<li><p><strong>ntp_cell</strong> (<em>float</em>) – Lower bound on proportion of expressed genes for cell QC.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>genes_select</strong> (<em>numpy.ndarray(dtype=’uint’)</em>) – Array of indices of genes passed QC.</p></li>
<li><p><strong>cells_select</strong> (<em>numpy.ndarray(dtype=’uint’)</em>) – Array of indices of cells passed QC.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Normalisr</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_api.html">User API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">All API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.association">normalisr.association</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.binnet">normalisr.binnet</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.coex">normalisr.coex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.de">normalisr.de</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.gocovt">normalisr.gocovt</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.lcpm">normalisr.lcpm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.norm">normalisr.norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.parallel">normalisr.parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-normalisr.qc">normalisr.qc</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="user_api.html" title="previous chapter">User API</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Lingfei Wang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="sources/all_api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>